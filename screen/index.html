<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>LickMe Touch Screen</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            background-size: cover;
            background-position: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #status {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="status">Connecting...</div>
    <canvas id="canvas"></canvas>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <!-- Shared config -->
    <script src="../shared/firebase-config.private.js"></script>
    <script src="../shared/firebase-config.js"></script>

    <script>
        // Get screen ID from URL parameter (default to 1)
        const urlParams = new URLSearchParams(window.location.search);
        const screenId = urlParams.get('screen') || '1';
        const screenKey = `screen${screenId}`;
        const screenIndex = parseInt(screenId) - 1; // 0, 1, or 2 for array indexing

        // Database references (set after auth)
        let database;
        let screenRef;
        let pixelsRef;
        let dripsRef;
        let currentArtworkRef;

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // State
        const pixelSize = CONFIG.PIXEL_SIZE;
        const localPixels = new Map(); // Local cache of pixels
        const dripPixels = new Map(); // Drip effect pixels
        const growthQueue = []; // Queue for spreading growth
        const drips = []; // Active drips
        const puddleHeights = new Map(); // Track puddle height at each x position
        let isGrowing = false;
        let currentArtworkIndex = 0;
        let artworkMetadata = []; // Loaded from API
        let currentImage = null;
        let isMaster = false;
        let masterCheckDone = false;

        // Offscreen canvas for color sampling
        let colorSampleCanvas = null;
        let colorSampleCtx = null;

        // Sample color from the image at given coordinates
        function sampleColor(x, y) {
            if (!colorSampleCtx || !currentImage) {
                return { r: 128, g: 128, b: 128 }; // Default gray
            }
            try {
                // Scale coordinates to sample canvas size
                const sampleX = Math.floor((x / canvas.width) * colorSampleCanvas.width);
                const sampleY = Math.floor((y / canvas.height) * colorSampleCanvas.height);
                const pixel = colorSampleCtx.getImageData(sampleX, sampleY, 1, 1).data;
                return { r: pixel[0], g: pixel[1], b: pixel[2] };
            } catch (e) {
                return { r: 128, g: 128, b: 128 };
            }
        }

        
        // Load artwork metadata - each set is a triptych
        async function loadArtworkMetadata() {
            const metadata = [];
            
            for (const artworkSet of CONFIG.ARTWORK_SETS) {
                const setImages = [];
                for (const url of artworkSet) {
                    try {
                        if (url.match(/\.(png|jpg|jpeg|gif|webp)$/i)) {
                            setImages.push({
                                name: `Artwork ${metadata.length + 1}`,
                                image: url
                            });
                        } else {
                            const response = await fetch(url);
                            if (response.ok) {
                                const data = await response.json();
                                setImages.push({
                                    name: data.name,
                                    image: data.image_url
                                });
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to load artwork:', url);
                    }
                }
                if (setImages.length === 3) {
                    metadata.push(setImages);
                }
            }
            return metadata;
        }

        // Load and display current artwork image
        function loadArtworkImage(index) {
            if (index < 0 || index >= artworkMetadata.length) return;

            const artworkSet = artworkMetadata[index]; // This is an array of 3 images
            if (!artworkSet || artworkSet.length !== 3) return;

            // Get the image for THIS screen (screenIndex: 0, 1, or 2)
            const artwork = artworkSet[screenIndex];
            if (!artwork || !artwork.image) return;

            // Set background image
            document.body.style.backgroundImage = `url('${artwork.image}')`;

            // Load image for canvas overlay
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.src = artwork.image;
            img.onload = () => {
                currentImage = img;
                // Redraw canvas with new image
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // Create offscreen canvas for color sampling
                colorSampleCanvas = document.createElement('canvas');
                colorSampleCanvas.width = img.width;
                colorSampleCanvas.height = img.height;
                colorSampleCtx = colorSampleCanvas.getContext('2d');
                colorSampleCtx.drawImage(img, 0, 0);
            };
            img.onerror = () => {
                // Fallback to dark background
                currentImage = null;
                colorSampleCanvas = null;
                colorSampleCtx = null;
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            };
        }

        // Clear all pixels (called on artwork change)
        function clearAllPixels() {
            localPixels.clear();
            dripPixels.clear();
            puddleHeights.clear();
            growthQueue.length = 0;
            drips.length = 0;
            isGrowing = false;
            // Clear canvas and redraw image
            if (currentImage) {
                ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Add a pixel locally and sync to Firebase
        // If color is provided, use it; otherwise sample from image
        function addPixel(x, y, color = null) {
            const snappedX = Math.floor(x / pixelSize) * pixelSize;
            const snappedY = Math.floor(y / pixelSize) * pixelSize;
            const key = `${snappedX}_${snappedY}`;

            if (snappedX < 0 || snappedX >= canvas.width || snappedY < 0 || snappedY >= canvas.height) {
                return false;
            }

            if (localPixels.has(key)) return false;

            const now = Date.now();
            // Use provided color or sample from image
            const pixelColor = color || sampleColor(snappedX, snappedY);

            const pixelData = {
                x: snappedX,
                y: snappedY,
                r: pixelColor.r,
                g: pixelColor.g,
                b: pixelColor.b,
                createdAt: firebase.database.ServerValue.TIMESTAMP
            };

            // Add locally with color
            localPixels.set(key, { x: snappedX, y: snappedY, r: pixelColor.r, g: pixelColor.g, b: pixelColor.b, createdAt: now });

            // Sync to Firebase
            pixelsRef.child(key).set(pixelData);

            return true;
        }

        // Fungus growth algorithm - spreads pixels organically
        function growFungus() {
            if (growthQueue.length === 0) {
                isGrowing = false;
                return;
            }

            const batchSize = 40;
            for (let i = 0; i < batchSize && growthQueue.length > 0; i++) {
                const { x, y, centerX, centerY, maxDistance, color } = growthQueue.shift();

                const directions = [
                    { dx: pixelSize, dy: 0 }, { dx: -pixelSize, dy: 0 },
                    { dx: 0, dy: pixelSize }, { dx: 0, dy: -pixelSize },
                    { dx: pixelSize, dy: pixelSize }, { dx: -pixelSize, dy: -pixelSize },
                    { dx: pixelSize, dy: -pixelSize }, { dx: -pixelSize, dy: pixelSize }
                ];

                // Shuffle directions for organic look
                for (let j = directions.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [directions[j], directions[k]] = [directions[k], directions[j]];
                }

                for (const { dx, dy } of directions) {
                    const newX = x + dx;
                    const newY = y + dy;

                    if (newX < 0 || newX >= canvas.width || newY < 0 || newY >= canvas.height) continue;

                    const key = `${newX}_${newY}`;
                    if (localPixels.has(key)) continue;

                    // Check distance from center to limit spread per touch
                    const distance = Math.sqrt(Math.pow(newX - centerX, 2) + Math.pow(newY - centerY, 2));
                    if (distance > maxDistance) continue;

                    // Random skip for organic edges
                    const orthogonalNeighbors = [
                        `${newX + pixelSize}_${newY}`,
                        `${newX - pixelSize}_${newY}`,
                        `${newX}_${newY + pixelSize}`,
                        `${newX}_${newY - pixelSize}`
                    ].filter(k => localPixels.has(k)).length;

                    if (orthogonalNeighbors > 1 && Math.random() < 0.5) continue;

                    // Growth chance - pass the inherited color
                    if (Math.random() < 0.4 && addPixel(newX, newY, color)) {
                        if (Math.random() < 0.75) {
                            growthQueue.push({ x: newX, y: newY, centerX, centerY, maxDistance, color });
                        }
                    }
                }
            }

            requestAnimationFrame(growFungus);
        }

        // Find pixels on the edge of the growth
        function findEdgePixels() {
            const edgePixels = [];
            localPixels.forEach((pixel, key) => {
                const neighbors = [
                    `${pixel.x + pixelSize}_${pixel.y}`, `${pixel.x - pixelSize}_${pixel.y}`,
                    `${pixel.x}_${pixel.y + pixelSize}`, `${pixel.x}_${pixel.y - pixelSize}`
                ];
                if (neighbors.some(nKey => !localPixels.has(nKey))) {
                    edgePixels.push(pixel);
                }
            });
            return edgePixels;
        }

        // Update drips - creates falling effect from edge pixels with puddle stacking
        function updateDrips() {
            // Spawn fewer but heavier drips
            if (Math.random() < 0.02 && localPixels.size > 10) {
                const edgePixels = findEdgePixels();
                const bottomEdges = edgePixels.filter(p => {
                    const below = `${p.x}_${p.y + pixelSize}`;
                    return !localPixels.has(below) && p.y < canvas.height - 100;
                });

                if (bottomEdges.length > 0) {
                    const dripSource = bottomEdges[Math.floor(Math.random() * bottomEdges.length)];
                    // Heavy drip - carries lots of "material" to deposit gradually
                    drips.push({
                        x: dripSource.x,
                        y: dripSource.y + pixelSize,
                        speed: 6 + Math.random() * 4,
                        color: { r: dripSource.r || 128, g: dripSource.g || 128, b: dripSource.b || 128 },
                        payload: 70 + Math.floor(Math.random() * 50), // Large payload
                        pooling: false, // Not yet pooling at bottom
                        createdAt: Date.now()
                    });
                }
            }

            // Update existing drips
            // Floor is at the bottom of canvas, snapped to grid
            const floorY = Math.floor(canvas.height / pixelSize) * pixelSize - pixelSize;

            for (let i = drips.length - 1; i >= 0; i--) {
                const drip = drips[i];
                drip.y += drip.speed;

                const snappedX = Math.floor(drip.x / pixelSize) * pixelSize;
                const snappedY = Math.floor(drip.y / pixelSize) * pixelSize;

                // Check what's at the drip's current position or below
                const currentKey = `${snappedX}_${snappedY}`;
                const belowKey = `${snappedX}_${snappedY + pixelSize}`;
                const atFloor = snappedY >= floorY;
                const hitPile = dripPixels.has(currentKey) || dripPixels.has(belowKey);

                // Track trail positions for visual rendering (not stored permanently)
                if (!drip.trail) drip.trail = [];
                drip.trail.push({ x: snappedX, y: snappedY });
                // Keep trail limited in length
                if (drip.trail.length > 50) drip.trail.shift();

                if (atFloor || hitPile) {
                    // Start pooling - drip stays and gradually deposits payload
                    drip.pooling = true;
                    drip.poolX = snappedX;
                    drip.y = floorY; // Stay at floor level
                }

                // If drip is pooling, gradually deposit payload
                if (drip.pooling && drip.payload > 0) {
                    const color = drip.color;
                    const now = Date.now();

                    // Deposit a few grains per frame for gradual effect
                    const grainsPerFrame = 3 + Math.floor(Math.random() * 3);

                    for (let p = 0; p < grainsPerFrame && drip.payload > 0; p++) {
                        drip.payload--;

                        // Start at drip position and flow downhill
                        let settleX = drip.poolX;
                        let settleY = floorY;

                        // Find current height at drip position
                        while (settleY >= 0 && dripPixels.has(`${settleX}_${settleY}`)) {
                            settleY -= pixelSize;
                        }

                        // Flow downhill - keep rolling towards lower side
                        for (let roll = 0; roll < 50; roll++) {
                            const leftX = settleX - pixelSize;
                            const rightX = settleX + pixelSize;

                            // Find height of adjacent columns
                            let leftY = floorY;
                            if (leftX >= 0) {
                                while (leftY >= 0 && dripPixels.has(`${leftX}_${leftY}`)) leftY -= pixelSize;
                            } else {
                                leftY = -999; // Off screen, can't go there
                            }

                            let rightY = floorY;
                            if (rightX < canvas.width) {
                                while (rightY >= 0 && dripPixels.has(`${rightX}_${rightY}`)) rightY -= pixelSize;
                            } else {
                                rightY = -999; // Off screen, can't go there
                            }

                            // Roll towards the lower side (higher Y = lower position)
                            // Add randomness: 5% chance to settle early, 10% chance to pick random direction
                            if (Math.random() < 0.05) {
                                break; // Random early settle
                            } else if (Math.random() < 0.1 && (leftY > settleY || rightY > settleY)) {
                                // Random direction instead of lowest
                                if (leftY > settleY && rightY > settleY) {
                                    if (Math.random() < 0.3) { settleX = leftX; settleY = leftY; }
                                    else { settleX = rightX; settleY = rightY; }
                                } else if (leftY > settleY) { settleX = leftX; settleY = leftY; }
                                else { settleX = rightX; settleY = rightY; }
                            } else if (leftY > settleY && leftY >= rightY) {
                                settleX = leftX;
                                settleY = leftY;
                            } else if (rightY > settleY) {
                                settleX = rightX;
                                settleY = rightY;
                            } else {
                                // Can't roll further, settle here
                                break;
                            }
                        }

                        // Place the grain
                        const settleKey = `${settleX}_${settleY}`;
                        if (settleY >= 0 && !dripPixels.has(settleKey)) {
                            dripPixels.set(settleKey, { x: settleX, y: settleY, r: color.r, g: color.g, b: color.b, createdAt: now });

                            // Sync to Firebase
                            dripsRef.child(settleKey).set({
                                x: settleX,
                                y: settleY,
                                r: color.r,
                                g: color.g,
                                b: color.b,
                                createdAt: firebase.database.ServerValue.TIMESTAMP
                            });
                        }
                    }

                    // Remove drip when payload is empty
                    if (drip.payload <= 0) {
                        drips.splice(i, 1);
                    }
                }
            }
        }

        // Spread effect from a touch point
        function triggerSpread(clientX, clientY) {
            const centerX = Math.floor(clientX / pixelSize) * pixelSize;
            const centerY = Math.floor(clientY / pixelSize) * pixelSize;

            // Sample color at the touch point - this color will spread outward
            const touchColor = sampleColor(centerX, centerY);

            // Reasonable spread distance per touch
            const maxDistance = 120;

            // Find edge pixels near the touch point to expand from
            const edgePixelsNearby = [];
            for (const [key, pixel] of localPixels) {
                const distance = Math.sqrt(Math.pow(pixel.x - centerX, 2) + Math.pow(pixel.y - centerY, 2));
                if (distance < 80) {
                    // Check if this is an edge pixel
                    const neighbors = [
                        `${pixel.x + pixelSize}_${pixel.y}`,
                        `${pixel.x - pixelSize}_${pixel.y}`,
                        `${pixel.x}_${pixel.y + pixelSize}`,
                        `${pixel.x}_${pixel.y - pixelSize}`
                    ];
                    const hasEmptyNeighbor = neighbors.some(n => !localPixels.has(n));
                    if (hasEmptyNeighbor) {
                        edgePixelsNearby.push(pixel);
                    }
                }
            }

            // If touching near existing pixels, expand from their edges
            if (edgePixelsNearby.length > 0) {
                // Pick some edge pixels to expand from - use the touch color
                const expandCount = Math.min(edgePixelsNearby.length, 10);
                for (let i = 0; i < expandCount; i++) {
                    const pixel = edgePixelsNearby[Math.floor(Math.random() * edgePixelsNearby.length)];
                    growthQueue.push({
                        x: pixel.x,
                        y: pixel.y,
                        centerX: pixel.x,
                        centerY: pixel.y,
                        maxDistance,
                        color: touchColor
                    });
                }
            } else {
                // New cluster - add center and seeds with the touch color
                addPixel(centerX, centerY, touchColor);

                const seedCount = 8;
                for (let i = 0; i < seedCount; i++) {
                    const angle = (Math.PI * 2 / seedCount) * i + Math.random() * 0.3;
                    const dist = pixelSize * (1 + Math.floor(Math.random() * 3));
                    const x = centerX + Math.cos(angle) * dist;
                    const y = centerY + Math.sin(angle) * dist;

                    if (addPixel(x, y, touchColor)) {
                        growthQueue.push({
                            x: Math.floor(x / pixelSize) * pixelSize,
                            y: Math.floor(y / pixelSize) * pixelSize,
                            centerX,
                            centerY,
                            maxDistance,
                            color: touchColor
                        });
                    }
                }
            }

            // Start growth if not already running
            if (!isGrowing && growthQueue.length > 0) {
                isGrowing = true;
                growFungus();
            }
        }

        // Touch event handlers
        function handleTouch(e) {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                triggerSpread(touch.clientX, touch.clientY);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
        }

        // Mouse fallback for testing
        function handleMouseMove(e) {
            if (e.buttons === 1) { // Left button held
                triggerSpread(e.clientX, e.clientY);
            }
        }

        function handleClick(e) {
            triggerSpread(e.clientX, e.clientY);
        }

        // Drawing loop
        function draw() {
            const currentTime = Date.now();

            // Update drips
            updateDrips();

            // Draw base image first
            if (currentImage) {
                ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            }

            // Draw pixels - fade from white to sampled color, then stay
            localPixels.forEach((pixel, key) => {
                const age = currentTime - pixel.createdAt;
                const r = pixel.r || 128;
                const g = pixel.g || 128;
                const b = pixel.b || 128;

                if (age < CONFIG.WHITE_TO_BLACK_MS) {
                    // White to sampled color transition
                    const ratio = age / CONFIG.WHITE_TO_BLACK_MS;
                    const pr = Math.floor(255 - (ratio * (255 - r)));
                    const pg = Math.floor(255 - (ratio * (255 - g)));
                    const pb = Math.floor(255 - (ratio * (255 - b)));
                    ctx.fillStyle = `rgb(${pr}, ${pg}, ${pb})`;
                    ctx.fillRect(pixel.x, pixel.y, pixelSize, pixelSize);
                } else {
                    // Stay at sampled color
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(pixel.x, pixel.y, pixelSize, pixelSize);
                }
            });

            // Draw drip pixels - fade from white to sampled color, then stay
            dripPixels.forEach((pixel, key) => {
                const age = currentTime - pixel.createdAt;
                const r = pixel.r || 128;
                const g = pixel.g || 128;
                const b = pixel.b || 128;

                if (age < CONFIG.WHITE_TO_BLACK_MS) {
                    // White to sampled color transition
                    const ratio = age / CONFIG.WHITE_TO_BLACK_MS;
                    const pr = Math.floor(255 - (ratio * (255 - r)));
                    const pg = Math.floor(255 - (ratio * (255 - g)));
                    const pb = Math.floor(255 - (ratio * (255 - b)));
                    ctx.fillStyle = `rgb(${pr}, ${pg}, ${pb})`;
                    ctx.fillRect(pixel.x, pixel.y, pixelSize, pixelSize);
                } else {
                    // Stay at sampled color
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(pixel.x, pixel.y, pixelSize, pixelSize);
                }
            });

            // Draw active drip trails (temporary, not stored)
            drips.forEach(drip => {
                if (drip.trail && drip.color) {
                    const r = drip.color.r;
                    const g = drip.color.g;
                    const b = drip.color.b;
                    drip.trail.forEach((pos, idx) => {
                        // Fade trail from transparent at top to solid at bottom
                        const alpha = (idx / drip.trail.length);
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        ctx.fillRect(pos.x, pos.y, pixelSize, pixelSize);
                    });
                }
            });

            // Update status
            // Debug: show first drip position
            let dripDebug = '';
            if (dripPixels.size > 0) {
                const firstDrip = dripPixels.values().next().value;
                dripDebug = ` | FirstDrip: ${firstDrip.x},${firstDrip.y}`;
            }
            statusEl.textContent = `Screen ${screenId} | Pixels: ${localPixels.size} | Drips: ${dripPixels.size} | H:${canvas.height}${dripDebug}${isMaster ? ' (Master)' : ''}`;

            requestAnimationFrame(draw);
        }

        // Artwork cycling - master logic
        function setupMasterCycling() {
            // Check if we should be master (first one to claim it)
            const masterRef = database.ref('master');

            masterRef.transaction((current) => {
                if (!current || Date.now() - current.lastHeartbeat > 10000) {
                    // No master or master is stale, claim it
                    return {
                        screenId: screenKey,
                        lastHeartbeat: firebase.database.ServerValue.TIMESTAMP
                    };
                }
                return; // Abort - master exists
            }).then((result) => {
                if (result.committed && result.snapshot.val()?.screenId === screenKey) {
                    isMaster = true;
                    startMasterCycle();
                }
                masterCheckDone = true;
            });

            // Heartbeat if we're master
            setInterval(() => {
                if (isMaster) {
                    masterRef.update({
                        lastHeartbeat: firebase.database.ServerValue.TIMESTAMP
                    });
                }
            }, 5000);
        }

        // Query Objkt.com for latest sale event
        async function getLatestSaleEvent() {
            const query = `
                query {
                    event(
                        where: {
                            marketplace_event_type: {
                                _in: ["list_buy", "english_auction_settle", "dutch_auction_buy", "offer_accept", "offer_floor_accept"]
                            }
                        }
                        order_by: {timestamp: desc}
                        limit: 1
                    ) {
                        id
                        timestamp
                        ophash
                        price_xtz
                        marketplace_event_type
                    }
                }
            `;

            try {
                const response = await fetch(CONFIG.OBJKT_GRAPHQL_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query })
                });

                if (!response.ok) {
                    console.error('Objkt API error:', response.status);
                    return null;
                }

                const data = await response.json();
                const event = data?.data?.event?.[0] || null;

                if (event) {
                    console.log('Latest sale event:', {
                        id: event.id,
                        type: event.marketplace_event_type,
                        price: event.price_xtz ? `${event.price_xtz} XTZ` : 'N/A',
                        timestamp: new Date(event.timestamp).toLocaleString(),
                        ophash: event.ophash
                    });
                }

                return event;
            } catch (error) {
                console.error('Failed to fetch latest sale event:', error);
                return null;
            }
        }

        function startMasterCycle() {
            let lastEventId = null;
            let isFirstPoll = true;

            // Poll for new sale events
            setInterval(async () => {
                if (!isMaster || artworkMetadata.length === 0) return;

                const latestEvent = await getLatestSaleEvent();
                if (!latestEvent) return;

                // Initialize tracking on first poll
                if (isFirstPoll) {
                    lastEventId = latestEvent.id;
                    console.log('ðŸŽ¨ Starting artwork cycling on sales. Watching for new events...');
                    isFirstPoll = false;
                    return;
                }

                // Check if this is a new sale event (different id)
                if (latestEvent.id !== lastEventId) {
                    console.log('ðŸ”” NEW SALE DETECTED! Switching artwork...');
                    console.log('   Type:', latestEvent.marketplace_event_type);
                    console.log('   Price:', latestEvent.price_xtz, 'XTZ');
                    console.log('   Event ID:', latestEvent.id);

                    const nextIndex = (currentArtworkIndex + 1) % artworkMetadata.length;

                    // Update Firebase (this triggers change for all screens)
                    currentArtworkRef.set({
                        index: nextIndex,
                        lastChanged: firebase.database.ServerValue.TIMESTAMP
                    });

                    // Clear pixels and drips in Firebase
                    pixelsRef.remove();
                    dripsRef.remove();
                    database.ref('screens/screen1/pixels').remove();
                    database.ref('screens/screen2/pixels').remove();
                    database.ref('screens/screen3/pixels').remove();
                    database.ref('screens/screen1/drips').remove();
                    database.ref('screens/screen2/drips').remove();
                    database.ref('screens/screen3/drips').remove();

                    // Update last known event
                    lastEventId = latestEvent.id;
                }

            }, CONFIG.OBJKT_POLL_INTERVAL_MS);
        }

        // Setup Firebase listeners (called after auth)
        function setupFirebaseListeners() {
            // Listen for artwork changes
            currentArtworkRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data && typeof data.index === 'number') {
                    if (data.index !== currentArtworkIndex) {
                        currentArtworkIndex = data.index;
                        clearAllPixels();
                        loadArtworkImage(currentArtworkIndex);
                    }
                }
            });

            // Listen for pixel updates from Firebase (for sync)
            pixelsRef.on('child_added', (snapshot) => {
                const key = snapshot.key;
                const data = snapshot.val();
                if (!localPixels.has(key) && data) {
                    localPixels.set(key, {
                        x: data.x,
                        y: data.y,
                        r: data.r || 128,
                        g: data.g || 128,
                        b: data.b || 128,
                        createdAt: data.createdAt || Date.now()
                    });
                }
            });

            pixelsRef.on('child_removed', (snapshot) => {
                localPixels.delete(snapshot.key);
            });

            // Listen for full clear
            screenRef.on('value', (snapshot) => {
                if (!snapshot.exists() || !snapshot.child('pixels').exists()) {
                    localPixels.clear();
                }
            });
        }

        // Initialize
        async function init() {
            statusEl.textContent = 'Authenticating...';

            // Initialize Firebase with anonymous auth
            const authSuccess = await initFirebase();
            if (!authSuccess) {
                statusEl.textContent = 'Error: Authentication failed';
                return;
            }

            // Set up database references after auth
            database = firebase.database();
            screenRef = database.ref(`screens/${screenKey}`);
            pixelsRef = screenRef.child('pixels');
            dripsRef = screenRef.child('drips');
            currentArtworkRef = database.ref('currentArtwork');

            // Setup Firebase listeners
            setupFirebaseListeners();

            statusEl.textContent = 'Loading artworks...';

            // Load artwork metadata
            artworkMetadata = await loadArtworkMetadata();

            if (artworkMetadata.length === 0) {
                statusEl.textContent = 'Error: No artworks loaded';
                return;
            }

            // Check current artwork index from Firebase
            const artworkSnapshot = await currentArtworkRef.once('value');
            const artworkData = artworkSnapshot.val();
            if (artworkData && typeof artworkData.index === 'number') {
                currentArtworkIndex = artworkData.index;
            } else {
                // Initialize if not set
                await currentArtworkRef.set({
                    index: 0,
                    lastChanged: firebase.database.ServerValue.TIMESTAMP
                });
            }

            // Load initial artwork
            loadArtworkImage(currentArtworkIndex);

            // Setup event listeners
            canvas.addEventListener('touchstart', handleTouch, { passive: false });
            canvas.addEventListener('touchmove', handleTouch, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('mousemove', handleMouseMove);

            // Report screen dimensions to Firebase for display scaling
            screenRef.child('dimensions').set({
                width: canvas.width,
                height: canvas.height
            });

            // Setup master cycling
            setupMasterCycling();

            // Start drawing
            draw();

            statusEl.textContent = `Screen ${screenId} | Ready`;
        }

        // Handle resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (currentImage) {
                ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
            }
            // Update dimensions in Firebase
            if (screenRef) {
                screenRef.child('dimensions').set({
                    width: canvas.width,
                    height: canvas.height
                });
            }
        });

        // Start
        init();
    </script>
</body>
</html>
